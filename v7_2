# Cyberpunk Dashboard – PCB v7.4
# - Animated diagonal grid
# - Neon buses/spines/accents + glowing dots
# - Bottom-left widget shows looping GIF (civic_spin.gif), no text

import sys, random, datetime
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QLabel, QGraphicsDropShadowEffect
from PyQt5.QtCore import Qt, QTimer, QPointF, QRect
from PyQt5.QtGui import QColor, QFont, QPainter, QPen, QPainterPath, QMovie

# ──────────────────────────────────────────────────────────────
# TUNABLES
# ──────────────────────────────────────────────────────────────
WIDGET_W, WIDGET_H = 250, 160
LEFT_X, RIGHT_X_GAP = 40, 40
TOP_Y, BOTTOM_Y_GAP = 50, 50

CYAN = QColor("#00ffff")
PINK = QColor("#ff00ff")
GRID_COLOR = QColor(30, 30, 30)
GRID_STEP = 40

BORDER_WIDTH = 4
RADIUS = 30
PADDING = 8
CORE = 3

BUS_OFFS = [-20, -10, 10, 20]
SPINE_OFFS = [-34, -32, 34, 36]
BRANCH_OFFSETS = [-13, 13]

# path to your GIF (put the file next to this script or use an absolute path)
CIVIC_GIF = "civic_spin.gif"

# ──────────────────────────────────────────────────────────────
# Neon helpers
# ──────────────────────────────────────────────────────────────
def neon_stroke(p: QPainter, path: QPainterPath, color: QColor, core_width: int):
    c1 = QColor(color); c1.setAlpha(60)
    c2 = QColor(color); c2.setAlpha(120)
    c3 = QColor(color); c3.setAlpha(255)
    for w, col in ((core_width*3, c1),
                   (int(core_width*1.7), c2),
                   (core_width, c3)):
        pen = QPen(col)
        pen.setWidth(w)
        pen.setCapStyle(Qt.RoundCap)
        pen.setJoinStyle(Qt.RoundJoin)
        p.setPen(pen)
        p.drawPath(path)

def neon_dot(p: QPainter, pos: QPointF, color: QColor, radius: int):
    c1 = QColor(color); c1.setAlpha(60)
    c2 = QColor(color); c2.setAlpha(120)
    c3 = QColor(color); c3.setAlpha(255)
    for r, col in ((radius*2, c1), (int(radius*1.5), c2), (radius, c3)):
        p.setBrush(col)
        p.setPen(Qt.NoPen)
        p.drawEllipse(pos, r, r)

def ortho_path(points):
    path = QPainterPath(QPointF(points[0][0], points[0][1]))
    for x, y in points[1:]:
        path.lineTo(QPointF(x, y))
    return path

# ──────────────────────────────────────────────────────────────
# Widget (cyan border glow + reduced pink text glow) + optional GIF
# ──────────────────────────────────────────────────────────────
class GlowWidget(QWidget):
    def __init__(self, text="", parent=None, big=False):
        super().__init__(parent)
        self.setFixedSize(WIDGET_W, WIDGET_H)
        self.big = big

        # Text label (hidden when we show a movie)
        self.label = QLabel(text, self)
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setStyleSheet("color:#ff00ff; background:transparent;")
        size = 30 if big else 23
        font = QFont("Neuropolitical", size, QFont.Bold)
        if font.family() == "Sans Serif":
            font = QFont("Courier New", size, QFont.Bold)
        self.label.setFont(font)
        self.label.resize(self.size())

        # Cyan border glow
        border_glow = QGraphicsDropShadowEffect(self)
        border_glow.setBlurRadius(80)
        border_glow.setColor(CYAN)
        border_glow.setOffset(0, 0)
        self.setGraphicsEffect(border_glow)

        # Reduced pink text glow
        text_glow = QGraphicsDropShadowEffect(self.label)
        text_glow.setBlurRadius(15)
        glow_color = QColor(PINK); glow_color.setAlpha(30)
        text_glow.setColor(glow_color)
        text_glow.setOffset(0, 0)
        self.label.setGraphicsEffect(text_glow)

        # Optional movie holder (created when needed)
        self.movie_label = None
        self.movie = None

        self.setAttribute(Qt.WA_TranslucentBackground)

    def setText(self, html):
        # Ensure text label is visible if used
        if self.movie_label:
            self.movie_label.hide()
        self.label.show()
        self.label.setText(html)

    def setMovie(self, gif_path):
        """Attach a looping GIF that is scaled and centered within the inner frame."""
        # Create the QLabel for the movie if needed
        if self.movie_label is None:
            self.movie_label = QLabel(self)
            self.movie_label.setAttribute(Qt.WA_TranslucentBackground)
            self.movie_label.setStyleSheet("background:transparent;")
        # Load movie
        self.movie = QMovie(gif_path)
        self.movie.setCacheMode(QMovie.CacheAll)
        self.movie.setSpeed(100)  # 100% speed
        self.movie_label.setMovie(self.movie)
        # Size & position inside the inner inset
        inner = self._inner_rect()
        # Leave a bit of padding so it never overlaps the border
        pad = 6
        inner = inner.adjusted(pad, pad, -pad, -pad)
        self.movie.setScaledSize(inner.size())
        self.movie_label.setGeometry(inner)
        self.movie.start()

        # Hide text when movie shown
        self.label.hide()
        self.movie_label.show()

    def _inner_rect(self) -> QRect:
        # Inner rounded inset used by the cyan inner frame
        return self.rect().adjusted(22, 22, -22, -22)

    def paintEvent(self, _):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)

        # outer cyan rounded frame
        pen = QPen(CYAN)
        pen.setWidth(BORDER_WIDTH)
        pen.setJoinStyle(Qt.RoundJoin)
        p.setPen(pen)
        p.setBrush(Qt.NoBrush)
        rect = self.rect().adjusted(4, 4, -4, -4)
        p.drawRoundedRect(rect, RADIUS, RADIUS)

        # faint inner inset frame
        inset = self._inner_rect()
        faint = QColor(CYAN); faint.setAlpha(60)
        pen2 = QPen(faint); pen2.setWidth(2)
        p.setPen(pen2)
        p.drawRoundedRect(inset, RADIUS-10, RADIUS-10)
        p.end()

# ──────────────────────────────────────────────────────────────
# Main Window
# ──────────────────────────────────────────────────────────────
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Cyberpunk Dashboard – PCB v7.4")
        self.setFixedSize(640, 480)
        self.setStyleSheet("background-color:#0d0d0d;")

        # Animated grid state
        self.grid_spacing = GRID_STEP
        self.grid_offset_x = 0
        self.grid_offset_y = 0
        self.grid_speed = 0.6  # px per tick (diagonal)

        # Widgets
        self.top_left = self._mk(LEFT_X, TOP_Y, big=True)
        self.top_right = self._mk(self.width()-RIGHT_X_GAP-WIDGET_W, TOP_Y)
        self.bottom_left = self._mk(LEFT_X, self.height()-BOTTOM_Y_GAP-WIDGET_H)
        self.bottom_right = self._mk(self.width()-RIGHT_X_GAP-WIDGET_W,
                                     self.height()-BOTTOM_Y_GAP-WIDGET_H)

        # Replace text in bottom-left with the GIF
        self.bottom_left.setMovie(CIVIC_GIF)

        # DHT availability (optional)
        try:
            import Adafruit_DHT
            self.SENSOR_AVAILABLE = True
            self.sensor_type = Adafruit_DHT.DHT22
            self.sensor_pin = 4
            self.Adafruit_DHT = Adafruit_DHT
        except ImportError:
            self.SENSOR_AVAILABLE = False

        # Timers
        self.t_timer = QTimer(self)
        self.t_timer.timeout.connect(self.update_time)
        self.t_timer.start(1000)

        self.s_timer = QTimer(self)
        self.s_timer.timeout.connect(self.update_sensors)
        self.s_timer.start(10000)

        self.grid_timer = QTimer(self)
        self.grid_timer.timeout.connect(self.animate_grid)
        self.grid_timer.start(30)  # ~33 FPS

        self.update_time()
        self.update_sensors()

    def _mk(self, x, y, big=False):
        w = GlowWidget("Loading...", self, big=big)
        w.move(x, y)
        return w

    # ——— animated grid
    def animate_grid(self):
        self.grid_offset_x = (self.grid_offset_x + self.grid_speed) % self.grid_spacing
        self.grid_offset_y = (self.grid_offset_y + self.grid_speed) % self.grid_spacing
        self.update()

    def update_time(self):
        now = datetime.datetime.now()
        t = now.strftime("%H:%M")
        d = now.strftime("%d-%m-%Y")
        self.top_left.setText(
            f"<span style='font-size:30pt'>{t}</span><br>"
            f"<span style='font-size:14pt'>{d}</span>"
        )

    def update_sensors(self):
        if getattr(self, "SENSOR_AVAILABLE", False):
            h, T = self.Adafruit_DHT.read_retry(self.sensor_type, self.sensor_pin)
            if h is None or T is None:
                self.top_right.setText("Temp:<br>-- °C")
                self.bottom_right.setText("Humidity:<br>-- %")
            else:
                self.top_right.setText(f"Temp:<br>{T:.1f} °C")
                self.bottom_right.setText(f"Humidity:<br>{h:.1f} %")
        else:
            T = random.uniform(18, 24)
            H = random.uniform(40, 60)
            self.top_right.setText(f"Temp:<br>{T:.1f} °C (demo)")
            self.bottom_right.setText(f"Humidity:<br>{H:.1f} % (demo)")

    def paintEvent(self, _):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)

        # ── animated diagonal grid
        p.setPen(QPen(GRID_COLOR, 1))
        gx = int(self.grid_offset_x)
        gy = int(self.grid_offset_y)
        w, h = self.width(), self.height()
        for x in range(-GRID_STEP, w + GRID_STEP, GRID_STEP):
            p.drawLine(x + gx, 0, x + gx, h)
        for y in range(-GRID_STEP, h + GRID_STEP, GRID_STEP):
            p.drawLine(0, y + gy, w, y + gy)

        # anchors
        TL, TR, BL, BR = (
            self.top_left.geometry(),
            self.top_right.geometry(),
            self.bottom_left.geometry(),
            self.bottom_right.geometry(),
        )

        mid_x = (TL.right() + TR.left()) // 2
        top_bus_y, bot_bus_y = TL.center().y(), BL.center().y()
        tl_r, tr_l = (TL.right() + PADDING, TL.center().y()), (TR.left() - PADDING, TR.center().y())
        bl_r, br_l = (BL.right() + PADDING, BL.center().y()), (BR.left() - PADDING, BR.center().y())

        # buses (cyan)
        for o in BUS_OFFS:
            y = top_bus_y + o
            path = ortho_path([(tl_r[0], y), (mid_x - 28, y), (mid_x - 28, y + 12),
                               (mid_x - 12, y + 12), (mid_x - 12, y), (tr_l[0], y)])
            neon_stroke(p, path, CYAN, CORE)
        for o in BUS_OFFS:
            y = bot_bus_y + o
            path = ortho_path([(bl_r[0], y), (mid_x + 28, y), (mid_x + 28, y - 12),
                               (mid_x + 12, y - 12), (mid_x + 12, y), (br_l[0], y)])
            neon_stroke(p, path, CYAN, CORE)

        # vertical spines (cyan)
        mid_gap_top = TL.bottom() + PADDING - 40
        mid_gap_bot = BR.top() - PADDING + 40
        for o in SPINE_OFFS:
            x = mid_x + o
            path = ortho_path([
                (x, mid_gap_top),
                (x, (mid_gap_top + mid_gap_bot) // 2 - 27),
                (x + (30 if o < 10 else 30), (mid_gap_top + mid_gap_bot) // 2 - 2),
                (x, (mid_gap_top + mid_gap_bot) // 2 + 27),
                (x, mid_gap_bot),
            ])
            neon_stroke(p, path, CYAN, CORE // 3)
            
             # left cyan accents
        left_inner_x = TL.left() + 60
        num_traces = 2
        gap_top = TL.bottom() + 4
        gap_bot = BL.top() - 4
        gap_height = gap_bot - gap_top
        spacing = max(1, gap_height // (num_traces + 1))
        for i in range(num_traces):
            y1 = gap_top + (i + 1) * spacing
            y2 = gap_bot - (i + 1) * spacing
            mid_y = (y1 + y2) // 2
            jog = -40 if i % 2 == 0 else 40
            path = ortho_path([(left_inner_x, y1), (left_inner_x + jog, mid_y), (left_inner_x, y2)])
            width = CORE if i % 2 == 0 else max(1, CORE // 2)
            neon_stroke(p, path, CYAN, width)

        # right cyan motherboard style + glowing nodes
        right_x = TR.right() - 60
        gap_top_r, gap_bot_r = TR.bottom(), BR.top()
        center_y_r = (gap_top_r + gap_bot_r) // 2
        path = ortho_path([(right_x, gap_top_r), (right_x, gap_bot_r)])
        neon_stroke(p, path, CYAN, CORE)
        for o in BRANCH_OFFSETS:
            y = center_y_r + o
            if gap_top_r < y < gap_bot_r:
                path = ortho_path([(right_x, y), (right_x - 80, y)])
                neon_stroke(p, path, CYAN, CORE // 2)
                neon_dot(p, QPointF(right_x - 80, y), CYAN, 5)

        # bottom horizontal base lines (bright pink glow)
        base_y = BR.bottom() + 18
        for w in (1, 3):
            path = ortho_path([(TL.left() + 20, base_y + 6 * w),
                               (TR.right() - 40, base_y + 6 * w)])
            neon_stroke(p, path, PINK, w)

        p.end()

# ──────────────────────────────────────────────────────────────
if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec_())
