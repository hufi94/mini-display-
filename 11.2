# Cyberpunk Dashboard – PCB v10.5.1
# Dual BME280 temps (Inside/Outside) in TOP-RIGHT. Bottom-right kept EMPTY.
# UI/layout/lines/Civic exactly as your v10.4; humidity removed from UI.

import sys, os, random, datetime, glob, time
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QLabel, QGraphicsDropShadowEffect
from PyQt5.QtCore import Qt, QTimer, QPointF
from PyQt5.QtGui import QColor, QFont, QPainter, QPen, QPainterPath, QImage, QPixmap

# ───────────────────────────────────────────────
# SETTINGS (from your v10.4)
# ───────────────────────────────────────────────
WIDGET_W, WIDGET_H = 270, 170
EDGE_MARGIN_X = 21
EDGE_MARGIN_Y = 29

CYAN = QColor("#00ffff")
PINK = QColor("#ff00ff")
BORDER_WIDTH = 6
RADIUS = 30
PADDING = 8
CORE = 3

BUS_OFFS = [-20, -10, 10, 20]
SPINE_OFFS = [-34, -32, 34, 36]
BRANCH_OFFSETS = [-13, 13]

FRAMES_DIR = "/home/matteo94/Desktop/cd/civic_frames_alpha"

# ───────────────────────────────────────────────
# BME280 – Dual sensor support (Pi 5, I2C bus 14)
# ───────────────────────────────────────────────
class DualBME280:
    def __init__(self):
        self.inside = None
        self.outside = None
        try:
            from adafruit_extended_bus import ExtendedI2C
            import adafruit_bme280
            self._bme280 = adafruit_bme280
            i2c = ExtendedI2C(14)
            # 0x76 → Inside (default), 0x77 → Outside (jumper SDO/ADDR)
            try:
                s = adafruit_bme280.Adafruit_BME280_I2C(i2c, address=0x76)
                s.sea_level_pressure = 1013.25
                self.inside = s
                print("[BME280] Inside @0x76")
            except Exception:
                pass
            try:
                s = adafruit_bme280.Adafruit_BME280_I2C(i2c, address=0x77)
                s.sea_level_pressure = 1013.25
                self.outside = s
                print("[BME280] Outside @0x77")
            except Exception:
                pass
            if not (self.inside or self.outside):
                print("[WARN] No BME280 on bus 14 (0x76/0x77). Demo mode.")
        except Exception as e:
            print(f"[WARN] BME280 init failed: {e}")
            self._bme280 = None

    def read(self):
        def safe_read(s):
            try:
                return (round(s.temperature, 1), round(s.humidity, 1), round(s.pressure, 1))
            except Exception:
                return (None, None, None)

        in_t = in_h = in_p = None
        out_t = out_h = out_p = None
        if self.inside:  in_t, in_h, in_p = safe_read(self.inside)
        if self.outside: out_t, out_h, out_p = safe_read(self.outside)

        # Demo if nothing connected
        if in_t is None and out_t is None:
            in_t  = round(random.uniform(21, 25), 1)
            out_t = round(in_t - random.uniform(0, 6), 1)
            return {"inside_temp": in_t, "outside_temp": out_t, "ok": False, "source": "DEMO"}

        return {"inside_temp": in_t, "outside_temp": out_t, "ok": True,
                "source": f"{'IN' if self.inside else ''}{'/OUT' if self.outside else ''}"}

# ───────────────────────────────────────────────
# Helpers and Widgets (unchanged visuals)
# ───────────────────────────────────────────────
def neon_stroke(p, path, color, core_width):
    c1 = QColor(color); c1.setAlpha(60)
    c2 = QColor(color); c2.setAlpha(120)
    c3 = QColor(color); c3.setAlpha(255)
    for w, col in ((core_width*3, c1),(int(core_width*1.7), c2),(core_width, c3)):
        pen = QPen(col); pen.setWidth(w)
        pen.setCapStyle(Qt.RoundCap); pen.setJoinStyle(Qt.RoundJoin)
        p.setPen(pen); p.drawPath(path)

def neon_dot(p, pos, color, radius):
    for a, s in ((60,2),(120,1.5),(255,1)):
        c = QColor(color); c.setAlpha(a)
        p.setBrush(c); p.setPen(Qt.NoPen); p.drawEllipse(pos, radius*s, radius*s)

def ortho_path(points):
    path = QPainterPath(QPointF(points[0][0], points[0][1]))
    for x, y in points[1:]: path.lineTo(QPointF(x, y))
    return path

class FramePlayerWidget(QLabel):
    def __init__(self, parent=None, fps=30):
        super().__init__(parent)
        self.setAutoFillBackground(False)
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        self.setStyleSheet("background: transparent;")
        self.frames=[]; self.idx=0
        self.timer=QTimer(self); self.timer.timeout.connect(self._next)
        self.interval=int(1000/max(1,fps))

    def load_dir(self, dir_path):
        files=sorted(glob.glob(os.path.join(dir_path,"*.png")))
        self.frames=[QImage(f).convertToFormat(QImage.Format_ARGB32_Premultiplied) for f in files]
        print(f"[CIVIC] Loaded {len(self.frames)} frames from: {dir_path}")
        self.idx=0
        if self.frames: self._paint_current()
        else: self.setText("No frames found")

    def start(self):
        if self.frames: self.timer.start(self.interval)
    def stop(self): self.timer.stop()

    def _paint_current(self):
        if not self.frames: return
        size=self.size()
        canvas=QImage(size,QImage.Format_ARGB32_Premultiplied); canvas.fill(Qt.transparent)
        frame=self.frames[self.idx].scaled(size,Qt.KeepAspectRatio,Qt.SmoothTransformation)
        x=(size.width()-frame.width())//2; y=(size.height()-frame.height())//2
        p=QPainter(canvas); p.setCompositionMode(QPainter.CompositionMode_Source)
        p.drawImage(x,y,frame); p.end()
        self.setPixmap(QPixmap.fromImage(canvas))

    def resizeEvent(self,e): super().resizeEvent(e); self._paint_current()
    def _next(self):
        if self.frames: self.idx=(self.idx+1)%len(self.frames); self._paint_current()

class GlowWidget(QWidget):
    def __init__(self, text="", parent=None, big=False):
        super().__init__(parent)
        self.setFixedSize(WIDGET_W, WIDGET_H); self.big = big
        self.label=QLabel(text,self); self.label.setAlignment(Qt.AlignCenter)
        self.label.setStyleSheet("color:#ff00ff; background:transparent;")
        size=30 if big else 23
        font=QFont("Neuropolitical",size,QFont.Bold)
        if font.family()=="Sans Serif": font=QFont("Courier New",size,QFont.Bold)
        self.label.setFont(font); self.label.resize(self.size())
        self.label.setContentsMargins(20,14,20,14)
        border_glow=QGraphicsDropShadowEffect(self); border_glow.setBlurRadius(200)
        border_glow.setColor(CYAN); border_glow.setOffset(2,2); self.setGraphicsEffect(border_glow)
        text_glow=QGraphicsDropShadowEffect(self.label); text_glow.setBlurRadius(15)
        gc=QColor(PINK); gc.setAlpha(30); text_glow.setColor(gc); text_glow.setOffset(0,0)
        self.label.setGraphicsEffect(text_glow); self.setAttribute(Qt.WA_TranslucentBackground)

    def _inner_rect(self): return self.rect().adjusted(22,22,-22,-22)
    def setText(self,html): self.label.setText(html); self.label.show()
    def paintEvent(self,_):
        p=QPainter(self); p.setRenderHint(QPainter.Antialiasing)
        pen=QPen(CYAN); pen.setWidth(BORDER_WIDTH); p.setPen(pen)
        p.drawRoundedRect(self.rect().adjusted(4,4,-4,-4),RADIUS,RADIUS); p.end()

# ───────────────────────────────────────────────
# MAIN WINDOW
# ───────────────────────────────────────────────
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Cyberpunk Dashboard – PCB v10.5.1")
        self.setFixedSize(640, 480)
        self.setStyleSheet("background-color:#0d0d0d;")

        # grid animation
        self.grid_step=40; self.grid_offset_x=0.0; self.grid_offset_y=0.0
        self.grid_timer=QTimer(self); self.grid_timer.timeout.connect(self.animate_grid); self.grid_timer.start(40)

        # widgets
        self.top_left  = self._mk(EDGE_MARGIN_X, EDGE_MARGIN_Y, big=True)
        self.top_right = self._mk(self.width()-EDGE_MARGIN_X-WIDGET_W, EDGE_MARGIN_Y)
        self.bottom_left  = self._mk(EDGE_MARGIN_X, self.height()-EDGE_MARGIN_Y-WIDGET_H)
        self.bottom_right = self._mk(self.width()-EDGE_MARGIN_X-WIDGET_W,
                                     self.height()-EDGE_MARGIN_Y-WIDGET_H)

        # Civic (bigger)
        self.civic_player=FramePlayerWidget(self.bottom_left, fps=25)
        w=self.bottom_left.width(); h=self.bottom_left.height()
        margin=-7
        self.civic_player.setGeometry(margin, margin, w-2*margin, h-2*margin)
        self.civic_player.load_dir(FRAMES_DIR); self.civic_player.start()
        self.bottom_left.label.hide(); self.civic_player.raise_()

        # Dual BME280
        self.sensors = DualBME280()

        # Make bottom-right permanently empty
        self.bottom_right.label.clear()
        self.bottom_right.label.hide()

        # timers
        self.t_timer=QTimer(self); self.t_timer.timeout.connect(self.update_time); self.t_timer.start(1000)
        self.s_timer=QTimer(self); self.s_timer.timeout.connect(self.update_sensors); self.s_timer.start(5000)
        self.update_time(); self.update_sensors()

    def _mk(self,x,y,big=False):
        w=GlowWidget("",self,big); w.move(x,y); return w

    def update_time(self):
        now=datetime.datetime.now()
        t=now.strftime("%H:%M"); d=now.strftime("%d-%m-%Y")
        self.top_left.setText(
            f"<span style='font-size:41pt'>{t}</span><br>"
            f"<span style='font-size:16pt'>{d}</span>"
        )

    def update_sensors(self):
        d=self.sensors.read()

        # TOP-RIGHT: Inside + Outside temperature only (bigger)
        inside = f"{int(round(d['inside_temp']))}°C" if d['inside_temp'] is not None else "--"
        outside = f"{int(round(d['outside_temp']))}°C" if d['outside_temp'] is not None else "--"

        GAP_PT = 14  # ↑ increase/decrease to change the distance between rows

        self.top_right.setText(
            f"""
            <table width='100%' cellspacing='0' cellpadding='0'>
              <tr>
                <td align='left'><span style='font-size:18pt'>Inside</span></td>
                <td align='right'><span style='font-size:23pt; color:#ff00ff'>{inside}</span></td>
              </tr>

              <!-- Spacer row: QLabel respects this because it contains text (&nbsp;) -->
              <tr>
                <td colspan='2' align='center'>
                  <span style='font-size:{GAP_PT}pt'>&nbsp;</span>
                </td>
              </tr>

              <tr>
                <td align='left'><span style='font-size:18pt'>Outside</span></td>
                <td align='right'><span style='font-size:23pt; color:#ff00ff'>{outside}</span></td>
              </tr>
            </table>
            """
        )
       

        # BOTTOM-RIGHT: keep empty
        self.bottom_right.label.clear()
        self.bottom_right.label.hide()

        # Keep Civic textless
        self.bottom_left.label.hide()

        print(f"[{d['source']}] IN={d['inside_temp']}°C  OUT={d['outside_temp']}°C  ok={d['ok']}")

    def animate_grid(self):
        self.grid_offset_x+=0.5; self.grid_offset_y+=0.5; self.update()

    def paintEvent(self,_):
        p=QPainter(self); p.setRenderHint(QPainter.Antialiasing)

        # Animated grid
        grid_color=QColor(40,40,40,120); pen=QPen(grid_color); pen.setWidth(1); p.setPen(pen)
        step=self.grid_step; ox,oy=self.grid_offset_x,self.grid_offset_y
        for x in range(-step*2,self.width()+step*2,step):
            p.drawLine(int(x+(ox%step)),0,int(x+(ox%step)),self.height())
        for y in range(-step*2,self.height()+step*2,step):
            p.drawLine(0,int(y+(oy%step)),self.width(),int(y+(oy%step)))

        # Neon PCB overlays (unchanged from your v10.4)
        TL, TR, BL, BR = (self.top_left.geometry(), self.top_right.geometry(),
                          self.bottom_left.geometry(), self.bottom_right.geometry())
        mid_x = (TL.right() + TR.left()) // 2
        top_bus_y, bot_bus_y = TL.center().y(), BL.center().y()
        tl_r, tr_l = (TL.right()+PADDING, TL.center().y()), (TR.left()-PADDING, TR.center().y())
        bl_r, br_l = (BL.right()+PADDING, BL.center().y()), (BR.left()-PADDING, BR.center().y())

        for o in BUS_OFFS:
            y=top_bus_y+o
            path=ortho_path([(tl_r[0],y),(mid_x-28,y),(mid_x-28,y+12),
                             (mid_x-12,y+12),(mid_x-12,y),(tr_l[0],y)])
            neon_stroke(p,path,CYAN,CORE)
        for o in BUS_OFFS:
            y=bot_bus_y+o
            path=ortho_path([(bl_r[0],y),(mid_x+28,y),(mid_x+28,y-12),
                             (mid_x+12,y-12),(mid_x+12,y),(br_l[0],y)])
            neon_stroke(p,path,CYAN,CORE)

        mid_gap_top = TL.bottom()+PADDING-40
        mid_gap_bot = BR.top()-PADDING+40
        for o in ( -34,-32,34,36 ):
            x=mid_x+o
            path=ortho_path([(x,mid_gap_top),
                             (x,(mid_gap_top+mid_gap_bot)//2-27),
                             (x+30,(mid_gap_top+mid_gap_bot)//2-2),
                             (x,(mid_gap_top+mid_gap_bot)//2+27),
                             (x,mid_gap_bot)])
            neon_stroke(p,path,CYAN,max(1,CORE//3))

        left_inner_x = TL.left()+70
        gap_top = TL.bottom()+4
        gap_bot = BL.top()-4
        gap_height = gap_bot-gap_top
        spacing = max(1, gap_height//(2+1))
        for i in range(2):
            y1=gap_top+(i+1)*spacing
            y2=gap_bot-(i+1)*spacing
            mid_y=(y1+y2)//2
            jog=-40 if i%2==0 else 40
            path=ortho_path([(left_inner_x,y1),(left_inner_x+jog,mid_y),(left_inner_x,y2)])
            width=CORE if i%2==0 else max(1,CORE//2)
            neon_stroke(p,path,CYAN,width)

        right_x = TR.right()-60
        gap_top_r, gap_bot_r = TR.bottom(), BR.top()
        center_y_r=(gap_top_r+gap_bot_r)//2
        path=ortho_path([(right_x,gap_top_r),(right_x,gap_bot_r)])
        neon_stroke(p,path,CYAN,CORE)
        for o in (-13,13):
            y=center_y_r+o
            if gap_top_r < y < gap_bot_r:
                path=ortho_path([(right_x,y),(right_x-80,y)])
                neon_stroke(p,path,CYAN,max(1,CORE//2))
                neon_dot(p,QPointF(right_x-80,y),CYAN,5)

        base_y = BR.bottom()+4
        for w in (1,3):
            path=ortho_path([(TL.left()+20,base_y+6*w),(TR.right()-40,base_y+6*w)])
            neon_stroke(p,path,PINK,w)

        p.end()

# ───────────────────────────────────────────────
if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec_())
