# Cyberpunk Dashboard – PCB v7.5
# Fix: civic GIF visible and looping in bottom-left widget

import sys, os, random, datetime
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QLabel, QGraphicsDropShadowEffect
from PyQt5.QtCore import Qt, QTimer, QPointF, QRect
from PyQt5.QtGui import QColor, QFont, QPainter, QPen, QPainterPath, QMovie
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from PyQt5.QtMultimediaWidgets import QVideoWidget
from PyQt5.QtCore import QUrl

# ───────────────────────────────────────────────
# SETTINGS
# ───────────────────────────────────────────────
WIDGET_W, WIDGET_H = 250, 160
LEFT_X, RIGHT_X_GAP = 40, 40
TOP_Y, BOTTOM_Y_GAP = 50, 50

CYAN = QColor("#00ffff")
PINK = QColor("#ff00ff")
GRID_COLOR = QColor(30, 30, 30)
GRID_STEP = 40
BORDER_WIDTH = 4
RADIUS = 30
PADDING = 8
CORE = 3

BUS_OFFS = [-20, -10, 10, 20]
SPINE_OFFS = [-34, -32, 34, 36]
BRANCH_OFFSETS = [-13, 13]

# ABSOLUTE path is safer for Pi
# Attach MP4 Civic video (no ghosting)
video_path = "/home/matteo94/Desktop/cd/civic_spin_fixed.mp4"  # or civic_spin_clean.mp4
self.video_widget = QVideoWidget(self.bottom_left)
self.video_widget.setGeometry(-10, -10, 270, 180) # match widget size
self.video_player = QMediaPlayer(None, QMediaPlayer.VideoSurface)
self.video_player.setVideoOutput(self.video_widget)
self.video_player.setMedia(QMediaContent(QUrl.fromLocalFile(video_path)))
self.video_player.setMuted(True)
self.video_player.play()

# ───────────────────────────────────────────────
# Glow + Paint helpers
# ───────────────────────────────────────────────
def neon_stroke(p, path, color, core_width):
    c1 = QColor(color); c1.setAlpha(60)
    c2 = QColor(color); c2.setAlpha(120)
    c3 = QColor(color); c3.setAlpha(255)
    for w, col in ((core_width*3, c1),
                   (int(core_width*1.7), c2),
                   (core_width, c3)):
        pen = QPen(col)
        pen.setWidth(w)
        pen.setCapStyle(Qt.RoundCap)
        pen.setJoinStyle(Qt.RoundJoin)
        p.setPen(pen)
        p.drawPath(path)

def neon_dot(p, pos, color, radius):
    c1 = QColor(color); c1.setAlpha(60)
    c2 = QColor(color); c2.setAlpha(120)
    c3 = QColor(color); c3.setAlpha(255)
    for r, col in ((radius*2, c1), (int(radius*1.5), c2), (radius, c3)):
        p.setBrush(col)
        p.setPen(Qt.NoPen)
        p.drawEllipse(pos, r, r)

def ortho_path(points):
    path = QPainterPath(QPointF(points[0][0], points[0][1]))
    for x, y in points[1:]:
        path.lineTo(QPointF(x, y))
    return path

# ───────────────────────────────────────────────
# Widget class
# ───────────────────────────────────────────────
class GlowWidget(QWidget):
    def __init__(self, text="", parent=None, big=False):
        super().__init__(parent)
        self.setFixedSize(WIDGET_W, WIDGET_H)
        self.big = big
        self.movie = None
        self.movie_label = None

        # Text label
        self.label = QLabel(text, self)
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setStyleSheet("color:#ff00ff; background:transparent;")
        size = 30 if big else 23
        font = QFont("Neuropolitical", size, QFont.Bold)
        if font.family() == "Sans Serif":
            font = QFont("Courier New", size, QFont.Bold)
        self.label.setFont(font)
        self.label.resize(self.size())

        # Cyan border glow
        border_glow = QGraphicsDropShadowEffect(self)
        border_glow.setBlurRadius(80)
        border_glow.setColor(CYAN)
        border_glow.setOffset(0, 0)
        self.setGraphicsEffect(border_glow)

        # Reduced pink text glow
        text_glow = QGraphicsDropShadowEffect(self.label)
        text_glow.setBlurRadius(15)
        glow_color = QColor(PINK); glow_color.setAlpha(30)
        text_glow.setColor(glow_color)
        text_glow.setOffset(0, 0)
        self.label.setGraphicsEffect(text_glow)
        self.setAttribute(Qt.WA_TranslucentBackground)

    def _inner_rect(self):
        return self.rect().adjusted(22, 22, -22, -22)

    def setText(self, html):
        if self.movie_label:
            self.movie_label.hide()
        self.label.show()
        self.label.setText(html)

    def setMovie(self, gif_path):
        """Show animated GIF centered & looping."""
        if not os.path.exists(gif_path):
            print(f"[!] GIF not found at {gif_path}")
            return

        if self.movie_label is None:
            self.movie_label = QLabel(self)
            self.movie_label.setAttribute(Qt.WA_TranslucentBackground)
            self.movie_label.setStyleSheet("background:transparent;")
            self.movie_label.lower()  # ensure under border glow

        self.movie = QMovie(gif_path)
        self.movie.setCacheMode(QMovie.CacheAll)
        self.movie.setSpeed(100)
        self.movie.setScaledSize(self._inner_rect().size())

        self.movie_label.setGeometry(self._inner_rect())
        self.movie_label.setMovie(self.movie)
        self.movie.start()
        self.movie_label.show()
        self.label.hide()

        print("[✓] Loaded and started GIF:", gif_path)

    def paintEvent(self, _):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)
        pen = QPen(CYAN); pen.setWidth(BORDER_WIDTH)
        p.setPen(pen)
        p.drawRoundedRect(self.rect().adjusted(4, 4, -4, -4), RADIUS, RADIUS)
        faint = QColor(CYAN); faint.setAlpha(60)
        p.setPen(QPen(faint, 2))
        p.drawRoundedRect(self._inner_rect(), RADIUS-10, RADIUS-10)
        p.end()

# ───────────────────────────────────────────────
# Main Window
# ───────────────────────────────────────────────
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Cyberpunk Dashboard – PCB v8.3")
        self.setFixedSize(640, 480)
        self.setStyleSheet("background-color:#0d0d0d;")

        # grid settings
        self.grid_step = 40
        self.grid_offset_x = 0.0
        self.grid_offset_y = 0.0

        # animate grid
        self.grid_timer = QTimer(self)
        self.grid_timer.timeout.connect(self.animate_grid)
        self.grid_timer.start(40)  # smooth motion

        # ────────── widgets ──────────
        self.top_left = self._mk(LEFT_X, TOP_Y, big=True)
        self.top_right = self._mk(self.width()-RIGHT_X_GAP-WIDGET_W, TOP_Y)
        self.bottom_left = self._mk(LEFT_X, self.height()-BOTTOM_Y_GAP-WIDGET_H)
        self.bottom_right = self._mk(self.width()-RIGHT_X_GAP-WIDGET_W,
                                     self.height()-BOTTOM_Y_GAP-WIDGET_H)
        # Attach GIF
        self.bottom_left.setMovie(CIVIC_GIF)
        
        try:
            import Adafruit_DHT
            self.SENSOR_AVAILABLE = True
            self.sensor_type = Adafruit_DHT.DHT22
            self.sensor_pin = 4
            self.Adafruit_DHT = Adafruit_DHT
        except ImportError:
            self.SENSOR_AVAILABLE = False

        self.t_timer = QTimer(self)
        self.t_timer.timeout.connect(self.update_time)
        self.t_timer.start(1000)

        self.s_timer = QTimer(self)
        self.s_timer.timeout.connect(self.update_sensors)
        self.s_timer.start(10000)

        self.update_time()
        self.update_sensors()

    def _mk(self, x, y, big=False):
        w = GlowWidget("", self, big=big)
        w.move(x, y)
        return w

    def update_time(self):
        now = datetime.datetime.now()
        t = now.strftime("%H:%M")
        d = now.strftime("%d-%m-%Y")
        self.top_left.setText(
            f"<span style='font-size:30pt'>{t}</span><br>"
            f"<span style='font-size:14pt'>{d}</span>"
        )

    def update_sensors(self):
        if getattr(self, "SENSOR_AVAILABLE", False):
            h, T = self.Adafruit_DHT.read_retry(self.sensor_type, self.sensor_pin)
            if h is None or T is None:
                self.top_right.setText("Temp:\n-- °C")
                self.bottom_right.setText("Humidity:\n-- %")
            else:
                self.top_right.setText(f"Temp:\n{T:.1f} °C")
                self.bottom_right.setText(f"Humidity:\n{h:.1f} %")
        else:
            T = random.uniform(18, 24)
            H = random.uniform(40, 60)
            self.top_right.setText(f"Outside:\n{T:.1f} °C")
            self.bottom_right.setText(f"Inside:\n{H:.1f} %")
    

    # <-- FIX: properly defined at class level -->
    def animate_grid(self):
        # move diagonally (slower)
        self.grid_offset_x += 0.5
        self.grid_offset_y += 0.5
        self.update()

    def paintEvent(self, _):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)

        # ────── continuous background grid (darker) ──────
        grid_color = QColor(40, 40, 40, 120)  # darker gray
        pen = QPen(grid_color)
        pen.setWidth(1)
        p.setPen(pen)

        step = self.grid_step
        ox = self.grid_offset_x
        oy = self.grid_offset_y

        # draw vertical lines across window
        for x in range(-step*2, self.width() + step*2, step):
            px = int(x + (ox % step))
            p.drawLine(px, 0, px, self.height())

        # draw horizontal lines across window
        for y in range(-step*2, self.height() + step*2, step):
            py = int(y + (oy % step))
            p.drawLine(0, py, self.width(), py)

        # ────── neon PCB overlays ──────
        TL, TR, BL, BR = (
            self.top_left.geometry(),
            self.top_right.geometry(),
            self.bottom_left.geometry(),
            self.bottom_right.geometry(),
        )

        mid_x = (TL.right() + TR.left()) // 2
        top_bus_y, bot_bus_y = TL.center().y(), BL.center().y()
        tl_r, tr_l = (TL.right() + PADDING, TL.center().y()), (TR.left() - PADDING, TR.center().y())
        bl_r, br_l = (BL.right() + PADDING, BL.center().y()), (BR.left() - PADDING, BR.center().y())

        # buses
        for o in BUS_OFFS:
            y = top_bus_y + o
            path = ortho_path([(tl_r[0], y), (mid_x - 28, y), (mid_x - 28, y + 12),
                               (mid_x - 12, y + 12), (mid_x - 12, y), (tr_l[0], y)])
            neon_stroke(p, path, CYAN, CORE)
        for o in BUS_OFFS:
            y = bot_bus_y + o
            path = ortho_path([(bl_r[0], y), (mid_x + 28, y), (mid_x + 28, y - 12),
                               (mid_x + 12, y - 12), (mid_x + 12, y), (br_l[0], y)])
            neon_stroke(p, path, CYAN, CORE)

        # vertical spines
        mid_gap_top = TL.bottom() + PADDING - 40
        mid_gap_bot = BR.top() - PADDING + 40
        for o in SPINE_OFFS:
            x = mid_x + o
            path = ortho_path([
                (x, mid_gap_top),
                (x, (mid_gap_top + mid_gap_bot) // 2 - 27),
                (x + 30, (mid_gap_top + mid_gap_bot) // 2 - 2),
                (x, (mid_gap_top + mid_gap_bot) // 2 + 27),
                (x, mid_gap_bot),
            ])
            neon_stroke(p, path, CYAN, max(1, CORE // 3))

        # left cyan accents
        left_inner_x = TL.left() + 60
        num_traces = 2
        gap_top = TL.bottom() + 4
        gap_bot = BL.top() - 4
        gap_height = gap_bot - gap_top
        spacing = max(1, gap_height // (num_traces + 1))
        for i in range(num_traces):
            y1 = gap_top + (i + 1) * spacing
            y2 = gap_bot - (i + 1) * spacing
            mid_y = (y1 + y2) // 2
            jog = -40 if i % 2 == 0 else 40
            path = ortho_path([(left_inner_x, y1), (left_inner_x + jog, mid_y), (left_inner_x, y2)])
            width = CORE if i % 2 == 0 else max(1, CORE // 2)
            neon_stroke(p, path, CYAN, width)

        # right cyan traces
        right_x = TR.right() - 60
        gap_top_r, gap_bot_r = TR.bottom(), BR.top()
        center_y_r = (gap_top_r + gap_bot_r) // 2
        path = ortho_path([(right_x, gap_top_r), (right_x, gap_bot_r)])
        neon_stroke(p, path, CYAN, CORE)
        for o in BRANCH_OFFSETS:
            y = center_y_r + o
            if gap_top_r < y < gap_bot_r:
                path = ortho_path([(right_x, y), (right_x - 80, y)])
                neon_stroke(p, path, CYAN, max(1, CORE // 2))
                neon_dot(p, QPointF(right_x - 80, y), CYAN, 5)

        # bottom pink base lines
        base_y = BR.bottom() + 18
        for w in (1, 3):
            path = ortho_path([(TL.left() + 20, base_y + 6 * w),
                               (TR.right() - 40, base_y + 6 * w)])
            neon_stroke(p, path, PINK, w)

        p.end()


# ───────────────────────────────────────────────
if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec_())
